<!doctype html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>&lt;rl-display&gt; manual</title>
		<link rel="stylesheet" href="index.css" />
	</head>
	<body>

<h1>&lt;rl-display&gt; manual</h1>

<p>This page documents and demonstrates the &lt;rl-display&gt; web component. Its main goal is to provide a modern and aesthetically pleasing tty-like renderer, suitable for Roguelike games. &lt;rl-display&gt; remains true to the web platform, rendering individual glyphs via HTML DOM. This allows for CSS-based styling and the application of Web Animations for smoother visual experience.</p>

<p>All examples on this page are interactive; you can click and edit them as necessary. They are powered by the <a href="https://github.com/ondras/x-ample">&lt;x-ample&gt;</a> web component. Additional information:</p>
<ul>
	<li>Some examples use additional library code loaded from <a href="utils.js">utils.js</a>.</li>
	<li>Example code is wrapped inside an asynchronous generator. To display values from an example code, use the <code>yield</code> keyword.</li>
</ul>

<t-o-c selector="body > h2, body > h3"><h3>Table of Contents</h3></t-o-c>

<h2>Part 1: basic drawing</h2>

<p>Once you link the &lt;rl-display&gt; library to your HTML page, you can start using the corresponding HTML tag. Its instance can be created in three ways:</p>
<ol>
	<li>Via HTML markup</li>
	<li>Via JavaScript instantiation (<code>new</code> operator)</li>
	<li>Via JavaScript <code>document.createElement</code> call</li>
</ol>
<p>Manipulating the display is performed with JS calls, so it makes most sense to create the display via JavaScript as well. Let's create a display and draw some characters inside:</p>

<script type="application/x-ample">
let display = document.createElement("rl-display");

display.draw(8, 6, {ch:"@", fg:"red"});
display.draw(10, 5, {ch:"$", fg:"goldenrod"});
display.draw(12, 7, {ch:"g", fg:"lime"});

return display;
</script>

<p>The <code>draw</code> method is the main device for displaying stuff. Every call displays one character at a position given by two coordinates (x and y). The second argument is an object used to configure the visual properties. It might contain:</p>

<ul>
	<li><code>ch</code> &ndash; the character being drawn</li>
	<li><code>fg</code> &ndash; foreground (text) color</li>
	<li><code>bg</code> &ndash; background color</li>
</ul>

<p>These properties are optional. The foreground color defaults to gray and the background is transparent (so you see the black background color of the display itself). Let's fill the display with <a href="https://en.wikipedia.org/wiki/Interpunct">mid-dots</a> on a random background:</p>

<script type="application/x-ample">
let display = document.createElement("rl-display");

for (let i=0; i<display.cols; i++) {
	for (let j=0; j<display.rows; j++) {
		let bg = (Math.random() > 0.5 ? "#222" : "#444");
		display.draw(i, j, {ch:"Â·", bg});
	}
}

return display;
</script>

<h2>Part 2: styling and configuration</h2>

<p>Since &lt;rl-display&gt; is an HTML element and uses other HTML elements to show stuff, the primary device for styling is CSS. Some properties, however, are configured via JavaScript. In the example above, we see the <code>cols</code> and <code>rows</code> properties being used to retrieve the display's size <em>in characters</em>. We can use these properties to change the size as well:</p>

<script type="application/x-ample">
let d1 = document.createElement("rl-display");
let d2 = document.createElement("rl-display");
let d3 = document.createElement("rl-display");

d1.cols = d1.rows = 3;
d2.cols = d2.rows = 5;
d3.cols = d3.rows = 10;

let fragment = document.createDocumentFragment();
fragment.append(d1, " ", d2, " ", d3);
return fragment;
</script>

<p>Primary CSS properties used to adjust the display are:</p>

<ul>
	<li><code>display</code> &ndash; the default is <em>inline-flex</em>
	<li><code>background-color</code> &ndash; the default is <em>black</em>
	<li><code>color</code> &ndash; the default is <em>gray</em>
	<li><code>font-family</code> &ndash; the default is <em>monospace</em>
</ul>

<p>Let's try customizing these:</p>

<script type="application/x-ample">
let display = document.createElement("rl-display");
display.draw(10, 5, {ch:"@"});

display.style.color = "hotpink";
display.style.backgroundColor = "olivedrab";
display.style.fontFamily = "serif";

return display;
</script>

<p>Finally, to specify the <em>size</em> of individual characters, we use two custom CSS properties:</p>

<ul>
	<li><code>--tile-width</code> specifies the horizontal pitch</em>
	<li><code>--tile-height</code> specifies the vertical pitch as well as the font size</em>
</ul>

<script type="application/x-ample">
let display = document.createElement("rl-display");
display.cols = display.rows = 3;
display.draw(1, 1, {ch:"@", fg:"lime"});

display.style.setProperty("--tile-width", "20px");
display.style.setProperty("--tile-height", "30px");

return display;
</script>

<h2>Part 3: canvas vs. port</h2>

<p>What is the resulting size of a &lt;rl-display&gt;? The render width (in pixels) can be computed by multiplying <code>--tile-width</code> by the <code>cols</code> property (which specifies the number of characters, horizontally). However, game maps are often very large and it is not always possible to fit them on the screen. While you can reduce the font size (and therefore <code>--tile-width</code> and <code>--tile-height</code>) to make the display smaller, another approach is feasible as well: show only a subset of the large map.</p>

<p>Rendering a subset can be done in a straightforward manner, by manually computing the set of visible coordinates and drawing using an offset. This approach works, but becomes more difficult once you decide to move your camera. To facilitate easier rendering of smaller map subsets, &lt;rl-display&gt; offers another approach: the panning viewport. Let's see how that works.</p>

<p>When you adjust <code>display.cols</code> and <code>--tile-width</code>, you are influencing the display's final width indirectly. However, you are free to set the CSS width for the &lt;rl-display&gt; element directly. Once you do that, you decouple what the user sees (the <em>viewport</em>, whose size is defined explicitly) and what is drawn on the <em>canvas</em> (individual characters rendered via <code>display.draw</code>). Most frequently, the viewport is smaller than the canvas, resulting in an <em>overflow</em> (which can be typically observed on a &lt;textarea&gt; HTML element with fixed size). By default, the viewport is centered over the canvas. This can be changed using the <code>panTo</code> call:</p>

<script type="application/x-ample">
let utils = await import(`${location.href}utils.js`);
let display = document.createElement("rl-display");
yield display;

utils.drawRectangle(display);
display.draw(10, 5, {ch:"@", fg:"red"});

display.style.setProperty("width", `${13*20}px`);
display.style.setProperty("height", `${7*20}px`);

while (true) {
	await display.panTo(6, 3);
	await utils.sleep(1000);
	await display.panTo(13, 3);
	await utils.sleep(1000);
	await display.panTo(13, 6);
	await utils.sleep(1000);
	await display.panTo(6, 6);
	await utils.sleep(1000);
}

// fixme speed
</script>

<p>The arguments passed to `panTo` are display coordinates of the canvas character that shall be centered inside the viewport. It is possible to reset the viewport pan back to the canvas center using `panToCenter`:</p>

<script type="application/x-ample">
let utils = await import(`${location.href}utils.js`);
let display = document.createElement("rl-display");
yield display;

utils.drawRectangle(display);
display.cols = 21;
display.rows = 11;
display.draw(10, 5, {ch:"@", fg:"red"});

display.style.setProperty("width", `${13*20}px`);
display.style.setProperty("height", `${7*20}px`);

while (true) {
	await display.panTo(6, 3);
	await utils.sleep(1000);
	await display.panToCenter();
	await utils.sleep(1000);
}
</script>

<p>The &lt;rl-display&gt; element now behaves similarly to a regular web map. The last step to make the panning process even more fancy is to introduce <em>zooming</em>. Instead of drawing larger characters, we can temporarily scale up the whole display with the `scaleTo` method:</p>

<script type="application/x-ample">
let utils = await import(`${location.href}utils.js`);
let display = document.createElement("rl-display");
yield display;

utils.drawRectangle(display);
display.style.setProperty("width", `${13*20}px`);
display.style.setProperty("height", `${7*20}px`);

display.draw(10, 5, {ch:"@", fg:"red"});
await display.panTo(10, 5);

while (true) {
	await utils.sleep(1000);
	await display.scaleTo(3);
	await utils.sleep(1000);
	await display.scaleTo(1);
}
</script>

<p>Scaling uses a single numeric argument that specifies the final scaling ratio, one being the default zoom (where the characters are drawn at the size specified via <code>--tile-height</code>). Note that scaling maintains the viewport-to-canvas mapping established by the last `panTo` call.</p>

<p>Panning and scaling is animated and therefore asynchronous. These methods are returning <em>Promises</em>, so in order to combine panning and scaling, it can be useful to combine the retured values with <code>Promise.all</code>:</p>

<script type="application/x-ample">
let utils = await import(`${location.href}utils.js`);
let display = document.createElement("rl-display");
yield display;

utils.drawRectangle(display);
display.style.setProperty("width", `${13*20}px`);
display.style.setProperty("height", `${7*20}px`);

display.draw(12, 6, {ch:"@", fg:"red"});

while (true) {
	await Promise.all([
		display.panTo(12, 6),
		display.scaleTo(3)
	]);
	await utils.sleep(1000);

	await Promise.all([
		display.panTo(6, 3),
		display.scaleTo(1)
	]);
	await utils.sleep(1000);
}
</script>

<h2>Part 4: depth</h2>

<h2>Part 5: effects</h2>

<h2>Part 6: additional features</h2>

<script type="application/x-ample">
let utils = await import(`${location.href}utils.js`);

let display = document.createElement("rl-display");
for (let x=0;x<display.cols;x++) {
	for (let y=0;y<display.rows;y++) {
		let in_x = x * (display.cols-1-x);
		let in_y = y * (display.rows-1-y);
		let ch = in_x && in_y ? "." : "#";
		display.draw(x, y, {ch});
	}
}

yield display;

let pc = display.draw(5, 5, {ch:"@"});
while (true) {
	await utils.sleep(1000);
	await display.move(pc, 4, 4);
	await utils.sleep(1000);
	await display.move(pc, 3, 3);
}
</script>

<script type="module" src="./t-o-c.js"></script>
<script type="module" src="../rl-display.js"></script>
<script type="module">
	import XAmple from "https://cdn.jsdelivr.net/gh/ondras/x-ample@master/x-ample.js"

	function createExamples() {
		let selector = `script[type="application/x-ample"]`;
		[...document.querySelectorAll(selector)].forEach(node => XAmple.replaceScript(node));
	}

	await customElements.whenDefined("rl-display");
	createExamples();
</script>
	</body>
</html>
